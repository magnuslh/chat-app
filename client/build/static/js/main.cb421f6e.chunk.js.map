{"version":3,"sources":["components/Input.tsx","helpers/debounce.js","components/Message.tsx","components/Header.tsx","components/MessageGroup.tsx","components/Chat.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["Input","sendTyping","sendMessage","useState","value","setValue","useEffect","func","wait","immediate","timeout","debounce","submit","className","type","name","onChange","event","target","placeholder","onKeyPress","charCode","onClick","Message","createdAt","isSender","text","showTime","setShowTime","console","log","color","date","Date","minutes","getMinutes","fMinutes","format","getHours","visible","onMouseOver","onMouseLeave","Header","clients","connectedClients","length","join","MessageGroup","sender","children","classes","Chat","clearMessages","nickname","messages","messageElements","setMessageElements","end","useRef","messageGroups","currentGroup","groups","map","message","k","group","j","key","current","scrollIntoView","behavior","ref","socket","require","io","link","createHttpLink","uri","client","ApolloClient","cache","InMemoryCache","GET_HISTORY","gql","CLEAR_MESSAGES","App","setMessages","setClients","setSomeonesTyping","useStateWithCallbackLazy","setNickname","a","mutate","mutation","res","data","error","query","getHistory","on","prevState","nick","callback","otherClients","filter","disconnect","emit","Boolean","window","location","hostname","match","addEventListener","scrollTo","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch"],"mappings":"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","file":"static/js/main.cb421f6e.chunk.js","sourcesContent":["import React, { useState, useEffect } from \"react\";\nimport { debounce } from \"../helpers/debounce\";\n\ninterface InputProps {\n  sendMessage: (text: string) => void;\n  sendTyping: (typing: boolean) => void;\n}\nconst Input = ({ sendTyping, sendMessage }: InputProps) => {\n  const [value, setValue] = useState(\"\");\n\n  useEffect(() => {\n    sendTyping(true);\n    debounce(() => sendTyping(false), 1000);\n  }, [value]);\n  const submit = () => {\n    if (value !== \"\") {\n      sendMessage(value);\n      setValue(\"\");\n    }\n  };\n  return (\n    <div className=\"w-full p-4 flex bg-gray-200\">\n      <input\n        type=\"text\"\n        name=\"message\"\n        value={value}\n        onChange={(event) => setValue(event.target.value)}\n        className=\"rounded p-3 pl-6 flex-grow shadow\"\n        placeholder=\"Say something...\"\n        onKeyPress={(event) => {\n          if (event.charCode === 13) {\n            submit();\n          }\n        }}\n      ></input>\n      <button\n        className=\"bg-blue-500 text-white rounded p-3 ml-2 shadow \"\n        onClick={submit}\n      >\n        Send\n      </button>\n    </div>\n  );\n};\nexport default Input;\n","export function debounce(func, wait, immediate) {\n  var timeout;\n  return function () {\n    var context = this,\n      args = arguments;\n    var later = function () {\n      timeout = null;\n      if (!immediate) func.apply(context, args);\n    };\n    var callNow = immediate && !timeout;\n    clearTimeout(timeout);\n    timeout = setTimeout(later, wait);\n    if (callNow) func.apply(context, args);\n  };\n}\n","import React, { useRef, useState } from \"react\";\ninterface MessageProps {\n  text: string;\n  isSender: boolean;\n  createdAt: string;\n}\nconst Message = ({ createdAt, isSender, text }: MessageProps) => {\n  const [showTime, setShowTime] = useState<boolean>(false);\n  console.log(createdAt);\n  const color = isSender\n    ? \"bg-blue-500 text-white \"\n    : \"bg-gray-200 text-gray-900 \";\n\n  let date = new Date(createdAt);\n\n  let minutes: number = date.getMinutes();\n  let fMinutes: string = \"\" + minutes;\n  if (minutes < 10) {\n    fMinutes = \"0\" + minutes;\n  }\n  let format = date.getHours() + \":\" + fMinutes;\n\n  let visible = showTime ? \"visible\" : \"invisible\";\n\n  return (\n    <div className=\"flex items-center\">\n      {\n        //position should be to the left of the message\n        isSender ? (\n          <div className={`text-gray-300 text-xs m-2 ${visible}`}>{format}</div>\n        ) : null\n      }\n      <div\n        onMouseOver={() => setShowTime(true)}\n        onMouseLeave={() => setShowTime(false)}\n        className={color + \" inline-block rounded p-2 shadow-md\"}\n      >\n        {text}\n      </div>\n      {\n        //position should be to the right of the message\n        !isSender ? (\n          <div className={`text-gray-300 text-xs m-2 ${visible}`}>{format}</div>\n        ) : null\n      }\n    </div>\n  );\n};\nexport default Message;\n","import React from \"react\";\ninterface HeaderProps {\n  clients: string[];\n}\nconst Header = ({ clients }: HeaderProps) => {\n  let connectedClients = \"\";\n  if (clients.length === 0) {\n    connectedClients = \"Looks you are the only one here\";\n  } else {\n    connectedClients = clients.join(\", \");\n  }\n\n  return (\n    <div className=\"w-full p-6 text-lg bg-gray-200 text-center text-gray-700 font-bold shadow-lg\">\n      {connectedClients}\n    </div>\n  );\n};\nexport default Header;\n","import React from \"react\";\ninterface MessageGroupProps {\n  children: any[];\n  sender: string;\n  // createdAt: string;\n  updatedAt?: string;\n  isSender: boolean;\n}\nconst MessageGroup = ({\n  isSender,\n  sender,\n  // createdAt,\n  children,\n}: MessageGroupProps) => {\n  const classes = \"p-2 m-1 \";\n\n  if (isSender) {\n    return (\n      <div className={classes + \" self-end text-right\"}>\n        <span className=\" text-gray-700\">{sender}</span>\n        <div className=\"flex flex-col items-end space-y-1\">{children}</div>\n      </div>\n    );\n  } else {\n    return (\n      <div className={classes + \" self-start text-left \"}>\n        <span className=\" text-gray-700\">{sender}</span>\n        <div className=\"flex flex-col items-start space-y-1\">{children}</div>\n      </div>\n    );\n  }\n};\nexport default MessageGroup;\n","import React, { useEffect, useState, useRef } from \"react\";\nimport Input from \"./Input\";\nimport Message from \"./Message\";\nimport Header from \"./Header\";\nimport MessageGroup from \"./MessageGroup\";\nimport { Message as MessageType } from \"../types/types\";\ninterface ChatProps {\n  messages: any[];\n  sendMessage: (text: string) => void;\n  clearMessages: () => void;\n  nickname: string;\n  clients: string[];\n  sendTyping: () => void;\n}\nconst Chat = ({\n  sendMessage,\n  sendTyping,\n  clearMessages,\n  clients,\n  nickname,\n  messages,\n}: ChatProps) => {\n  const [messageElements, setMessageElements] = useState<JSX.Element[]>([]);\n  const end = useRef<HTMLDivElement>(null);\n  useEffect(() => {\n    let messageGroups: any[] = [];\n    let currentGroup: number = 0;\n    let elements = messages.map((message, k) => {\n      if (k == 0) {\n        messageGroups[currentGroup] = [message];\n      } else if (k > 0 && message.sender === messages[k - 1].sender) {\n        messageGroups[currentGroup] = [...messageGroups[currentGroup], message];\n      } else {\n        currentGroup += 1;\n        messageGroups[currentGroup] = [message];\n      }\n      // return <Message key={k} text={message.text} />;\n    });\n    let groups = messageGroups.map((group, j) => {\n      let isSender = group[0].sender === nickname ? true : false;\n      let messages = group.map((message: MessageType, k: number) => {\n        return (\n          <Message\n            isSender={isSender}\n            createdAt={message.createdAt}\n            key={k}\n            text={message.text}\n          />\n        );\n      });\n      return (\n        <MessageGroup\n          isSender={isSender}\n          sender={group[0].sender}\n          // createdAt={group[0].createdAt}\n          key={j}\n        >\n          {messages}\n        </MessageGroup>\n      );\n    });\n    console.log(messageGroups);\n    setMessageElements(groups);\n  }, [messages, nickname]);\n\n  useEffect(() => {\n    end.current!.scrollIntoView({ behavior: \"smooth\" });\n  }, [messageElements]);\n  return (\n    <div className=\"h-full w-full  bg-gray-500 flex flex-col justify-end\">\n      <Header clients={clients} />\n      <div className=\"flex-grow flex flex-col p-4 overflow-y-scroll\">\n        {messageElements.length > 0 ? (\n          <button className=\"text-gray-400\" onClick={clearMessages}>\n            Clear All\n          </button>\n        ) : (\n          <span />\n        )}\n        {messageElements}\n        <div ref={end}></div>\n      </div>\n      {/*input*/}\n      <Input sendMessage={sendMessage} sendTyping={sendTyping}></Input>\n    </div>\n  );\n};\nexport default Chat;\n","import React, { useEffect, useState, useRef, useCallback } from \"react\";\nimport { useStateWithCallbackLazy } from \"use-state-with-callback\";\n\nimport {\n  ApolloClient,\n  InMemoryCache,\n  createHttpLink,\n  useQuery,\n  gql,\n} from \"@apollo/client\";\n\nimport Chat from \"./components/Chat\";\nimport { Message } from \"./types/types\";\n\n// const port = \"9000\";\nconst io = require(\"socket.io-client\");\nconst socket = io(\"/\");\n\nconst link = createHttpLink({\n  uri: \"/graphql\",\n});\n\nconst client = new ApolloClient({\n  link: link,\n  cache: new InMemoryCache(),\n});\n\nconst GET_HISTORY = gql`\n  query {\n    messages {\n      sender\n      text\n      createdAt\n      updatedAt\n    }\n  }\n`;\n\nconst CLEAR_MESSAGES = gql`\n  mutation {\n    clearMessages {\n      success\n    }\n  }\n`;\n\nfunction App() {\n  const [messages, setMessages] = useState<Message[]>([]);\n  const [clients, setClients] = useState<string[]>([]);\n\n  const [someonesTyping, setSomeonesTyping] = useState<boolean>(false);\n  const [nickname, setNickname] = useStateWithCallbackLazy<string>(\"\");\n\n  const clearMessages = async () => {\n    try {\n      let res = await client.mutate({\n        mutation: CLEAR_MESSAGES,\n      });\n      let messages = res.data;\n      setMessages([]);\n    } catch (error) {\n      console.error(error);\n    }\n  };\n\n  useEffect(() => {\n    const getHistory = async () => {\n      try {\n        let res = await client.query({\n          query: GET_HISTORY,\n        });\n        let messages = res.data.messages;\n        console.log(messages);\n        setMessages(messages);\n      } catch (error) {\n        console.error(error);\n      }\n    };\n    getHistory();\n\n    socket.on(\"bcMessage\", (data: Message) => {\n      setMessages((prevState) => [...prevState, data]);\n    });\n    socket.on(\n      \"nickname\",\n      (nick: string, clients: string[], callback: () => void) => {\n        setNickname(nick, () => {\n          callback();\n        });\n        let otherClients = clients.filter((client) => client !== nick);\n        setClients(otherClients);\n      }\n    );\n    socket.on(\"typing\", () => {\n      setSomeonesTyping(true);\n    });\n\n    return () => socket.disconnect();\n  }, []);\n\n  useEffect(() => {\n    socket.on(\"connectedClients\", (clients: string[]) => {\n      //nickname is not set yet.\n      let otherClients = clients.filter((client) => client !== nickname);\n      setClients(otherClients);\n    });\n  }, [nickname]);\n\n  const sendMessage = async (text: string) => {\n    console.log(nickname);\n    let message = {\n      text: text,\n      sender: nickname,\n    };\n    socket.emit(\"newMessage\", message);\n  };\n  const sendTyping = async () => {\n    socket.emit(\"typing\");\n  };\n\n  return (\n    <div className=\"h-screen w-full\">\n      <Chat\n        clients={clients}\n        nickname={nickname}\n        messages={messages}\n        clearMessages={() => clearMessages()}\n        sendMessage={(text: string) => sendMessage(text)}\n        sendTyping={() => sendTyping()}\n      />\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./assets/main.css\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\nwindow.addEventListener(\"load\", function () {\n  window.scrollTo(0, 0);\n});\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}